<?xml version="1.0"?>
<abiword version="unnumbered">
<!-- =====================================================================  -->
<!-- This file is an AbiWord document.                                      -->
<!-- AbiWord is a free, Open Source word processor.                         -->
<!-- You may obtain more information about AbiWord at www.abisource.com     -->
<!-- You should not edit this file by hand.                                 -->
<!-- =====================================================================  -->

<!--         Build_ID          = (none) -->
<!--         Build_Version     = unnumbered -->
<!--         Build_Options     = LicensedTrademarks:Off Debug:Off Gnome:Off -->
<!--         Build_Target      = /home/vince/rpm/BUILD/abi-0.7.9/src/Linux_2.2.14-1mdkmosix_i386_OBJ/obj -->
<!--         Build_CompileTime = 16:09:14 -->
<!--         Build_CompileDate = May  5 2000 -->

<section>
<p props="margin-left:0.0000in; margin-right:0.0000in; text-indent:0.0000in">Systems Assignment 						Shyam Visweswaran</p>
<p props="margin-left:0.0000in; margin-right:0.0000in; text-indent:0.0000in">Date: 14 March 2001</p>
<p props="margin-left:0.0000in; margin-right:0.0000in; text-align:center; text-indent:0.0000in"></p>
<p props="margin-left:0.0000in; margin-right:0.0000in; text-align:center; text-indent:0.0000in"><c props="font-weight:bold">Distributed mutual exclusion algorithms and failure detection</c></p>
<p props="margin-left:0.0000in; margin-right:0.0000in; text-align:left; text-indent:0.0000in"></p>
<p props="margin-left:0.0000in; margin-right:0.0000in; text-align:left; text-indent:0.0000in"><c props="font-weight:normal">Various algorithms have been described for achieving mutual exclusion in distributed systems. These include: one employing a central server, a ring-based token-passing algorithm and multicast-based algorithms (Ricart and Agrawala's algorithm and Maekawa's algorithm). I will describe the Ricart-Agrawala's algorithm in a perfect synchronous system with no process or communication failures and modify it to make it fault-tolerant assuming i) a synchronous network and ii) a asynchronous network.</c></p>
<p props="margin-left:0.0000in; margin-right:0.0000in; text-align:left; text-indent:0.0000in"></p>
<p props="margin-left:0.0000in; margin-right:0.0000in; text-align:left; text-indent:0.0000in"><c props="font-weight:normal">Ricart-Agrawala's algorithm uses a logical clock (like the Lamport clock) for time stamping requests and employs multicasting to request entry to a critical section (CS). When a process wants to enter a CS it multicasts a time stamped </c><c props="font-style:italic; font-weight:normal">request</c><c props="font-weight:normal"> to all other processes on the network. When a process receives a </c><c props="font-style:italic; font-weight:normal">request</c><c props="font-weight:normal"> it does one of the following: i) if it neither wants to enter the CS nor in the CS it immediately returns a </c><c props="font-style:italic; font-weight:normal">reply</c><c props="font-weight:normal"> message, ii) if it wants to enter the CS but the time stamp on the incoming request is smaller than its own request it returns a </c><c props="font-style:italic; font-weight:normal">reply</c><c props="font-weight:normal">, iii) otherwise it defers. Finally, when a process exits a CS it sends a </c><c props="font-style:italic; font-weight:normal">reply</c><c props="font-weight:normal"> message to all the deferred requests. Thus, gaining entry to CS takes 2(n - 1) messages (assuming n processes on the network): n - 1 to multicast the </c><c props="font-style:italic; font-weight:normal">request</c><c props="font-weight:normal">, followed by n - 1 </c><c props="font-style:italic; font-weight:normal">replies</c><c props="font-weight:normal">. The synchronization delay is only 1 message transmission time. Though this algorithm is expensive in terms of the number of messages generated, it satisfies the 3 main distributed mutual exclusion requirements. It achieves the </c><c props="font-style:italic; font-weight:normal">safety</c><c props="font-weight:normal"> property since all the &lt;message, time&gt; pairs that every process receives are totally ordered and hence the process sending the earliest message is granted its request. The algorithm also satisfies the properties of </c><c props="font-style:italic; font-weight:normal">liveness</c><c props="font-weight:normal"> (i.e. requests to enter CS eventually succeed) and </c><c props="font-style:italic; font-weight:normal">happened-before ordering</c><c props="font-weight:normal"> (i.e. if one request to enter CS happened before another then entry to CS granted in that order).</c></p>
<p props="margin-left:0.0000in; margin-right:0.0000in; text-align:left; text-indent:0.0000in"></p>
<p props="margin-left:0.0000in; margin-right:0.0000in; text-align:left; text-indent:0.0000in"><c props="font-weight:normal">As it stands, this algorithm has n points of failure, since if even one process fails, then the requesting processes wait indefinitely to enter CS. If at most 1 process can fail and the system is synchronous, the algorithm can be modified to reliably detect the failure. Simply making sure that all requests must be answered immediately is not sufficient to ensure fault tolerance. However, if, in addition, each requesting process adds a time-out, and assumes that any process that does not reply within the specified time interval has failed, then the algorithm becomes fault tolerant. This is still not completely fault tolerant! If a process answers immediately saying "no, do not enter, I will tell you when you may enter," the requesting process knows that that machine has not failed. If, then, the process fails, the requesting machine will wait forever for the deferred permission request. So, in addition, each process requesting entry to a critical section must periodically repeat its request.</c></p>
<p props="margin-left:0.0000in; margin-right:0.0000in; text-align:left; text-indent:0.0000in"></p>
<p props="margin-left:0.0000in; margin-right:0.0000in; text-align:left; text-indent:0.0000in"><c props="font-weight:normal">Theoretically, it is impossible to reliably detect failure in an asynchronous network. We could implement a practical failure detector that waits for a specified period of time to receive replies; thus converting the system into a partially synchronous one. The waiting time could be computed dynamically based on prior response times and other network factors, so that the probability of declaring a process 'dead' by a requesting process is reduced to some acceptable level.</c></p>
</section>
</abiword>
